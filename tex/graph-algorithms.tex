%%-----------------------------------------------------------------------%%
%%--- Graph Algorithms --------------------------------------------------%%

\chapter{Graph Algorithms}
\label{chap:graph_algorithms}

Graph algorithms have many applications. Suppose you are a salesman
with a product you would like to sell in several cities. To determine
the cheapest travel route from city-to-city, you must effectively
search a graph having weighted edges for the ``cheapest'' route
visiting each city once. Each vertex denotes a city you must visit and
each edge has a weight indicating either the distance from one city to
another or the cost to travel from one city to another.

Shortest path algorithms are some of the most important algorithms in
algorithmic graph theory. We shall examine several in this chapter.


%%-----------------------------------------------------------------------%%
%%--- Graph searching ---------------------------------------------------%%

\section{Graph searching}

This section discusses algorithms for

\begin{itemize}
\item
breadth-first searches,

\item
depth-first searches, and

\item
we explain how these relate to determining a graph's connectivity.
\end{itemize}


%%--- Breadth-first search ----------------------------------------------%%

\subsection{Breadth-first search}

\emph{Breadth-first search} (BFS) is a strategy for running through
the nodes of a graph. Suppose you want to count the number of vertices
(or edges) satisfying a property
$P$. Algorithm~\ref{alg:graph_algorithms:breadth_first_search}
presents a technique for finding the number of vertices satisfying $P$.

\begin{algorithm}[!htpb]
\SetLine
\dontprintsemicolon  % no semicolon at end of pseudocode statements
%% data section
\SetKwInOut{Input}{Input}
\SetKwInOut{Output}{Output}
\SetKwData{Count}{count}
\SetKwData{False}{False}
\SetKwData{True}{True}
%% input/output
\Input{A connected graph $G = (V, E)$ (and, optionally, a starting or
  ``root'' vertex $v_0 \in V$). A property $P$ to be tested.}
\Output{The number of vertices of $G$ satisfying $P$.}
\BlankLine
%% algorithm body
Create a queue $Q$ of ``unseen'' vertices initially containing a
starting vertex $v_0$.\;

Start a list $T$ of ``already seen'' vertices initially empty.\;

$\Count \leftarrow 0$\;

\For{$w \in Q$}{
  Test $w$ for $P$.\;
  \If{$P(w) = \True$}{
    $\Count \leftarrow \Count + 1$\label{abc:step:counter}
  }
  Add all neighbors of $w$ not in $T$ to $Q$.\;
  Remove all ``seen'' vertices $w$ from $Q$.\;
  Add such $w$ to $T$.\;
  \If{$T = V$}{
    \Return \Count
  }
}
\caption{Breadth-first search.}
\label{alg:graph_algorithms:breadth_first_search}
\end{algorithm}

%Algorithm to find a vertex satisfying property P.
%INPUT: Connected graph $G=(V,E)$ and a fixed
%starting vertex $v\in V$.
%OUTPUT:
%True if a vertex is found satisfying P,
%False otherwise.
%1. Start a queue Q containing $v$. Start a
%list of tested vertices, T, initially empty.
%2. For each element w of the queue:
%(a) Test w for P (stop if True).
%(b) Add all neighbors of w not yet tested
%to the queue.
%(c) Remove all tested vertices from the queue
%and add them to T.
%(d) If T=V, stop and return False.

Another version of
Algorithm~\ref{alg:graph_algorithms:breadth_first_search} is where you
are searching the graph for a vertex (or edge) satisfying a certain
property $P$. In that situation, you simply quit at the step where you
increment the counter, i.e. line~7 in
Algorithm~\ref{alg:graph_algorithms:breadth_first_search}. Other
variations are also possible as well.

For the example of the graph in
Figure~\ref{fig:introduction:types_of_walks}, the list of distances
from vertex \verb!a! to any other vertex is
%
\begin{center}
\fontsize{9pt}{9pt}
\selectfont
\tt
\begin{lstlisting}
[['a', 0], ['b', 1], ['c', 2], ['d', 3], ['e', 1], ['f', 2], ['g', 2]]
\end{lstlisting}
\end{center}
%
To create this list,
%
\begin{itemize}
\item
Start at \verb!a! and compute the distance from \verb!a! to itself.

\item
Move to each neighbor of \verb!a!, namely \verb!b! and \verb!e!, and
compute the distance fromm \verb!a! to each of them.

\item
Move to each ``unseen'' neighbor of \verb!b!, namely just \verb!c!,
and compute the distance fromm \verb!a! to it.

\item
Move to each ``unseen'' neighbor of \verb!e!, namely just \verb!f!,
and compute the distance from \verb!a! to it.

\item
Move to each ``unseen'' neighbor of \verb!c!, namely just \verb!d!,
and compute the distance fromm \verb!a! to it.

\item
Move to each ``unseen'' neighbor of \verb!f!, namely just \verb!g!,
and compute the distance fromm \verb!a! to it.
\end{itemize}

As an example, here is some Sage code which implements BFS to compute
the list distances from a given vertex.
%
\begin{center}
\fontsize{9pt}{9pt}
\selectfont
\tt
\begin{lstlisting}
def graph_distance(G, v0):
    """
    Breadth first search algorithm to find the
    distance from a fixed vertex $v_0$ to any
    other vertex.

    INPUT:
        G - a connected graph
        v0 - a vertex

    OUTPUT:
        D - a list of distances to
            every other vertex

    EXAMPLES:
        sage: G = Graph({1: [2, 4], 2: [1, 4], 3: [2, 6],
                         4: [1, 3], 5: [4, 2], 6: [3, 1]})
        sage: v0 = 1
        sage: graph_distance(G,v0)
        [[1, 0], [2, 1], [3, 2], [4, 1], [5, 2], [6, 1]]
        sage: G = Graph({"a": ["b", "e"], "b": ["c", "e"], \
         "c": ["d", "e"], "d": ["f"], "e": ["f"], "f": ["g"], "g":["b"]})
        sage: v0 = "a"
        sage: graph_distance(G, v0)
        [['a', 0], ['b', 1], ['c', 2], ['d', 3], ['e', 1],
         ['f', 2], ['g', 2]]
        sage: G = Graph({1: [2,3], 2: [1, 3], 3: [2], 4: [5], 5: [6], 6: [5]})
        sage: v0 = 1
        sage: graph_distance(G, v0) # note G is disconnected
        [[1, 0], [2, 1], [3, 1]]
    """
    V = G.vertices()
    Q = [v0]
    T = []
    D = []
    while Q<>[] and T<>V:
        for v in Q:
            if not(v in T):
                D.append([v,G.distance(v0,v)])
            if v in Q:
                Q.remove(v)
            T.append(v)
            T = list(Set(T))
            Q = Q+[x for x in G.neighbors(v) if not(x in T+Q)]
            if T == V:
                break
    D.sort()
    print Q, T
    return D
\end{lstlisting}
\end{center}
%
\begin{exercise}
Using Sage's \verb!shortest_path! method, can you modify the above
function to return a list of shortest paths from $v_0$ to any other
vertex?
\end{exercise}


%%--- Depth-first search ------------------------------------------------%%

\subsection{Depth-first search}

A depth-first search is a type of algorithm that visits each vertex of
a graph, proceeding from vertex-to-vertex in this search but moving
along a spanning tree of that graph.

Suppose you have a normal $8 \times 8$ chess board in front of you,
with a single knight piece on the board. If you can find a sequence of
knight moves which visits each and every square exactly once, then you
will have found a so-called \emph{complete knight tour}.
\index{knight tour}
Naively, how do you find a complete knight tour? Intuitively, you
would make one knight move after another, recording each move to
ensure that you did not step on a square you have already visited,
until you could not make any more moves. It is very, very unlikely
that if do this you will have visited every square exactly once (if
you don't believe me, please try it yourself!). Acknowledging defeat,
at this stage, it might make sense to \emph{backtrack} a few moves and
try again, hoping you will not get ``stuck'' so soon. If you fail
again, try backtracking a few move moves and traverse yet another
path, hoping to make further progress. Repeat this until a compete
tour is found. This is an example of \emph{depth-first search}, also
sometimes called \emph{backtracking}.

Similar to BFS, \emph{depth-first search} (DFS) is an algorithm for
traversing a graph. One starts at a \emph{root vertex} and explores as
\emph{far as possible} along each branch before, if necessary,
backtracking along a new path. It is easier to see what this means in
the case of a rooted tree than for more general graphs, as illustrated
below.
\index{depth-first search}

Suppose you want to count the number of vertices (or edges) satisfying
a property $P$.

\begin{algorithm}[!htpb]
\SetLine
\dontprintsemicolon  % no semicolon at end of pseudocode statements
%% data section
\SetKwInOut{Input}{Input}
\SetKwInOut{Output}{Output}
\SetKwData{Count}{count}
\SetKwData{False}{False}
\SetKwData{True}{True}
%% input/output
\Input{A rooted tree $G = (V, E)$ with  root vertex $v_0 \in V$.}
\Output{\True if $G$ has a vertex satisfying $P$; \False otherwise.}
\BlankLine
%% algorithm body
Create a queue $Q$ of ``child'' vertices of the root $v_0$.\;
Initialize a list $S$ of ``seen'' vertices.\;
$\Count \leftarrow 0$\;
\For{$w \in Q$}{
  Test $w$ for $P$.\;
  \If{$P(w) = \True$}{
    $\Count \leftarrow \Count + 1$
  }
  Add $w$ to $S$.\;
  \If{$S = V$} {
    \Return \Count
  }
}
Call the DFS algorithm iteratively with the rooted subtree having $w$
and all its children as vertices and $w$ as the rooted vertex.
\caption{Depth-first search.}
\label{alg:graph_algorithms:depth_first_search}
\end{algorithm}

In the case of a graph, you can modify
Algorithm~\ref{alg:graph_algorithms:depth_first_search} to a so-called
iterative DFS. This modification applies DFS repeatedly with an
increasing depth of search at each step, until the diameter of the
graph is reached and all vertices are seen.

\subsection{Connectivity of a graph}

% This subsection is on how the above algorithms can be used
% to determine a graph's connectivity.


%%-----------------------------------------------------------------------%%
%%--- Dijkstra's algorithm ----------------------------------------------%%

\section{Dijkstra's algorithm}

See Dijkstra~\cite{Dijkstra1959}, section~24.3 of
Cormen~et~al.~\cite{CormenEtAl2001}, and section~12.6 of Berman and
Paul~\cite{BermanPaul1997}.

Dijkstra's algorithm, discovered by E.~Dijkstra in 1959, is a graph
search algorithm that solves the single-source shortest path problem
for a graph with nonnegative edge weights. For example, if the
vertices of a weighted graph represent cities and edge weights
represent distances between pairs of cities connected by a direct
road, Dijkstra's algorithm can be used to find the shortest route from
a fixed city to all other cities.

It is remarkable that, at the present state of knowledge, given two
distinct vertices $v, w$ of a graph $G$, the fastest algorithm
determining a shortest path from $v$ to $w$ is no faster (in general)
than the fastest algorithm determining a shortest path from $v$ to
\emph{any} other vertex of $G$.


%%-----------------------------------------------------------------------%%
%%--- Bellman-Ford algorithm --------------------------------------------%%

\section{Bellman-Ford algorithm}

See section~24.1 of Cormen~et~al.~\cite{CormenEtAl2001}, and
section~8.5 of Berman and Paul~\cite{BermanPaul1997}.


%%-----------------------------------------------------------------------%%
%%--- Floyd-Warshall algorithm ------------------------------------------%%

\section{Floyd-Warshall algorithm}

See section~25.2 of Cormen~et~al.~\cite{CormenEtAl2001}, and section
14.4 of Berman and Paul~\cite{BermanPaul1997}.


%%-----------------------------------------------------------------------%%
%%--- Johnson's algorithm -----------------------------------------------%%

\section{Johnson's algorithm}

See section~25.3 of Cormen~et~al.~\cite{CormenEtAl2001} and
Johnson~\cite{Johnson1977}.
