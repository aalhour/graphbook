%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% This file is part of the book
%%
%% Algorithmic Graph Theory
%% http://code.google.com/p/graph-theory-algorithms-book/
%%
%% Copyright (C) 2010 David Joyner <wdjoyner@gmail.com>
%% Copyright (C) 2009, 2010 Minh Van Nguyen <nguyenminh2@gmail.com>
%%
%% See the file COPYING for copying conditions.
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\chapter{Tree Data Structures}
\label{chap:tree_data_structures}

\begin{quote}
\includegraphics[scale=0.7]{image/tree-data-structures/tree.png} \\
\noindent
--- Randall Munroe\index{Munroe, Randall}, xkcd,
\url{http://xkcd.com/835/}
\end{quote}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\section{Priority queues}

A \emph{priority queue}\index{queue!priority} is essentially a queue
data structure with various accompanying rules regarding how to access
and manage elements of the queue. Recall from
section~\ref{subsec:graph_algorithms:breadth_first_search} that an
ordinary queue $Q$ has the following basic accompanying functions for
assessing and managing its elements:
%%
\begin{itemize}
\item $\dequeue(Q)$ --- Remove the front of $Q$.

\item $\enqueue(Q, e)$ --- Append the element $e$ to the end of $Q$.
\end{itemize}

If $Q$ is now a priority queue, each element is associated with a key
or priority $p \in X$ from a totally ordered\index{total order} set
$X$. A binary relation denoted by an infix operator, say ``$\leq$'',
is defined on all elements of $X$ such that the following properties
hold for all $a,b,c \in X$:
%%
\begin{itemize}
\item Totality: We have $a \leq b$ or $b \leq a$.

\item Antisymmetry: If $a \leq b$ and $b \leq a$, then $a = b$.

\item Transitivity: If $a \leq b$ and $b \leq c$, then $a \leq c$.
\end{itemize}
%%
If the above three properties hold for the relation ``$\leq$'', then we
say that ``$\leq$'' is a \emph{total order}\index{total order} on $X$
and that $X$ is a
\emph{totally ordered set}\index{set!totally ordered}. In all, if the
key of each element of $Q$ belongs to the same totally ordered
set $X$, we use the total order defined on $X$ to compare the keys of
the queue elements. For example, the set $\Z$ of integers is totally
ordered by the ``less than or equal to'' relation. If the key of each
$e \in Q$ is an element of $\Z$, we use the latter relation to compare
the keys of elements of $Q$. In the case of an ordinary queue, the
key of each queue element is its position index.

To extract from a priority\index{queue!priority} queue $Q$ an element
of lowest priority, we need to define the notion of smallest
priority or key. Let $p_i$ be the priority or key assigned to element
$e_i$ of $Q$. Then $p_{\min}$ is the lowest key if $p_{\min} \leq p$
for any element key $p$. The element with corresponding key
$p_{\min}$ is the minimum priority element. Based upon the notion of
key comparison, we define two operations on a priority queue:
%%
\begin{itemize}
\item $\insertElem(Q, e, p)$ --- Insert into $Q$ the element $e$ with
  key $p$.

\item $\extractMin(Q)$ --- Extract from $Q$ an element having the
  smallest priority.
\end{itemize}

An immediate application of priority queues is sorting a finite
sequence of items. Suppose $L$ is a finite list of $n > 0$ items on
which a total order is defined. Let $Q$ be an empty priority queue. In
the first phase of the priority queue sorting algorithm, we extract
each element $e \in L$ from $L$ and insert $e$ into $Q$ with key $e$
itself. In other words, each element $e$ is its own key. This first
phase of the sorting algorithm requires $n$ element extractions from
$L$ and $n$ element insertions into $Q$. The second phase of the
algorithm involves extracting elements from $Q$ via the $\extractMin$
operation. Queue elements are extracted via $\extractMin$ and inserted
back into $L$ in the order in which they are extracted from
$Q$. Algorithm~\ref{alg:tree_data_structures:priority_queue_sort}
presents pseudocode of our discussion. The runtime of
Algorithm~\ref{alg:tree_data_structures:priority_queue_sort} depends
on how the priority queue $Q$ is implemented.

\begin{algorithm}[!htbp]
\input{algorithm/tree-data-structures/priority-queue-sort.tex}
\caption{Sorting a sequence via priority queue.}
\label{alg:tree_data_structures:priority_queue_sort}
\end{algorithm}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\subsection{Sequence implementation}

A simple way to implement a priority queue is to maintain a sorted
sequence. Let $e_0, e_1, \dots, e_n$ be a sequence of $n - 1$ elements
with corresponding keys $k_0, k_1, \dots, k_n$ and suppose that the
$k_i$ all belong to the same totally ordered set $X$ having total
order $\leq$. Using the total order, we assume that the $k_i$ are
sorted as
\[
k_0 \leq k_1 \leq \cdots \leq k_n
\]
and $e_i \leq e_j$ if and only if $k_i \leq k_j$. Then we can consider
the queue $Q = [e_0, e_1, \dots, e_n]$ as a priority queue in which
the head is always the minimum element and the tail is always the
maximum element. Extracting the minimum element is simply a dequeue
operation that can be accomplished in constant time $O(1)$. However,
inserting a new element into $Q$ takes linear time.

Let $e$ be an element with corresponding key $k \in X$. Inserting $e$
into $Q$ requires that we maintain elements of $Q$ sorted according to
the total order $\leq$. If $Q$ is empty, we simply enqueue $e$ into
$Q$. Suppose now that $Q$ is a nonempty priority queue. If
$k \leq k_0$, then $e$ becomes the new head of $Q$. If $k_n \leq k$,
then $e$ becomes the new tail of $Q$. Inserting a new head or tail
into $Q$ each requires constant time $O(1)$. However, if
$k_1 \leq k \leq k_{n-1}$ then we need to traverse $Q$ starting from
$e_1$, searching for a position at which to insert $e$. Let $e_i$ be
the queue element at position $i$ within $Q$. If $k \leq k_i$ then we
insert $e$ into $Q$ at position $i$, thus moving $e_i$ to position
$i + 1$. Otherwise we next consider $e_{i+1}$ and repeat the above
comparison process. By hypothesis, $k_1 \leq k \leq k_{n-1}$ and
therefore inserting $e$ into $Q$ takes a worst-case runtime of $O(n)$.


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\section{Binary heaps}

A sequence implementation of priority queues has the advantage of
being simple to understand. Inserting an element into a sequence-based
priority queue requires linear time, which can quickly become
infeasible for queues containing hundreds of thousands or even
millions of elements. Can we do any better? Rather than using a sorted
sequence, we can use a binary tree to realize an implementation of
priority queues that is much more efficient than a sequence-based
implementation. In particular, we use a data structure called a
\emph{binary heap}\index{binary heap}, which allows us to perform
element insertion in logarithmic time.

In~\cite{Williams1964}, Williams introduced the heapsort algorithm and
described how to implement a priority queue using a binary heap. The
basic idea is to consider queue elements as nodes in a binary tree.


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\section{Binary search trees}

See section~3.6 of Gross and Yellen~\cite{GrossYellen1999}, and
chapter~12 of Cormen~et~al.~\cite{CormenEtAl2001}. See also
\url{http://en.wikipedia.org/wiki/Binary_search_tree}.


\begin{itemize}
\item records and keys

\item searching a binary search tree (BST)

\item inserting into a BST

\item deleting from a BST

\item traversing a BST

\item sorting using BST
\end{itemize}

A {\it binary search tree} (BST) is a rooted binary tree
$T=(V,E)$ having weighted vertices ${\rm wt}:V\to \R$ satisfying:
\index{binary search tree}
\index{BST}

\begin{itemize}
\item
 The left subtree of a vertex $v$ contains only vertices whose label
(or ``key'') is less than the label of $v$.
\item
The right subtree of a vertex $v$ contains only vertices whose label
  is greater than the label of $v$.
\item
Both the left and right subtrees must also be binary search trees.
\end{itemize}

From the above properties it naturally follows that:
{\it Each vertex has a distinct label.}


\subsubsection{Traversal}

The vertices of a BST $T$ can be visited retrieved in-order of the
weights of the vertices (i.e.,
using a symmetric search type) by recursively  traversing the left subtree of the
root vertex, then accessing the root vertex itself, then recursively traversing the
right subtree of the root node.

\subsubsection{Searching}

We are given a BST (i.e., a binary rooted tree with weighted vertices
having distinct weights satisfying the above criteria) $T$ and a
label $\ell$. For this search, we are looking for a vertex in $T$
whose label is $\ell$, if one exists.

We begin by examining the root vertex, $v_0$. If $\ell={\rm wt}(v_0)$,
the search is successful. If the $\ell<{\rm wt}(v_0)$,
search the left subtree. Similarly, if $\ell>{\rm wt}(v_0)$,
search the right subtree. This process is repeated until a vertex
$v\in V$ is found for which $\ell={\rm wt}(v)$,
or the indicated subtree is empty.


\subsubsection{Insertion}

We are given a BST (i.e., a binary rooted tree with weighted vertices
having distinct weights satisfying the above criteria) $T$ and a
label $\ell$. We assume $\ell$ is between the
lowest weight of $T$ and the highest weight.
For this procedure, we are looking for a ``parent''
vertex in $T$ which can ``adopt'' a new vertex $v$ having weight $\ell$
and for which this augmented tree $T\cup v$ satisfies
the criteria above.

Insertion proceeds as a search does. However, in this case, you are
searching for vertices $v_1,v_2\in V$ for which
${\rm wt}(v_1)<\ell < {\rm wt}(v_2)$. Once found, these
vertices will tell you where to insert $v$.

\subsubsection{Deletion}

As above, we are given a BST $T$ and a
label $\ell$. We assume $\ell$ is between the
lowest weight of $T$ and the highest weight.
For this procedure, we are looking for a vertex $v$ of
$T$ which has weight $\ell$. We want to remove $v$ from
$T$ (and therefore also the weight $\ell$ from the list of weights),
thereby creating a ``smaller'' tree $T- v$ satisfying
the criteria above.

Deletion proceeds as a search does. However, in this case, you are
searching for vertex $v\in V$ for which
${\rm wt}(v)=\ell$. Once found, we remove $v$ from $V$
and any edge $(u,v)\in E$ is replaced by $(u,w_1)$
and $(u,w_2)$, where $w_1.w_2\in V$ were the children of $v$
in $T$.

\subsubsection{Sorting}

A binary search tree can be used to implement a simple but efficient
sorting algorithm. Suppose we wish to sort a list of numbers
$L = [\ell_1, \ell_2,\dots, \ell_n]$. First, let $V=\{1,2,\dots,n\}$
be the vertices of a tree and weight vertex $i$ with $\ell_i$,
for $1\leq i\leq n$. In this case, we can traverse this tree
in order of its weights, thereby building a BST recursively.
This BST represents the sorting of the list $L$.
Generally, the information represented by each vertex is a
record (or list or dictionary), rather than a single data element. However,
for sequencing purposes, vertices are compared according to their
labels rather than any part of their associated records.

\subsubsection{Traversal}

The vertices of a BST $T$ can be visited retrieved in-order of the
weights of the vertices (i.e.,
using a symmetric search type) by recursively  traversing the left subtree of the
root vertex, then accessing the root vertex itself, then recursively traversing the
right subtree of the root node.

\subsubsection{Searching}

We are given a BST (i.e., a binary rooted tree with weighted vertices
having distinct weights satisfying the above criteria) $T$ and a
label $\ell$. For this search, we are looking for a vertex in $T$
whose label is $\ell$, if one exists.

We begin by examining the root vertex, $v_0$. If $\ell={\rm wt}(v_0)$,
the search is successful. If the $\ell<{\rm wt}(v_0)$,
search the left subtree. Similarly, if $\ell>{\rm wt}(v_0)$,
search the right subtree. This process is repeated until a vertex
$v\in V$ is found for which $\ell={\rm wt}(v)$,
or the indicated subtree is empty.


\subsubsection{Insertion}

We are given a BST (i.e., a binary rooted tree with weighted vertices
having distinct weights satisfying the above criteria) $T$ and a
label $\ell$. We assume $\ell$ is between the
lowest weight of $T$ and the highest weight.
For this procedure, we are looking for a ``parent''
vertex in $T$ which can ``adopt'' a new vertex $v$ having weight $\ell$
and for which this augmented tree $T\cup v$ satisfies
the criteria above.

Insertion proceeds as a search does. However, in this case, you are
searching for vertices $v_1,v_2\in V$ for which
${\rm wt}(v_1)<\ell < {\rm wt}(v_2)$. Once found, these
vertices will tell you where to insert $v$.

\subsubsection{Deletion}

As above, we are given a BST $T$ and a
label $\ell$. We assume $\ell$ is between the
lowest weight of $T$ and the highest weight.
For this procedure, we are looking for a vertex $v$ of
$T$ which has weight $\ell$. We want to remove $v$ from
$T$ (and therefore also the weight $\ell$ from the list of weights),
thereby creating a ``smaller'' tree $T- v$ satisfying
the criteria above.

Deletion proceeds as a search does. However, in this case, you are
searching for vertex $v\in V$ for which
${\rm wt}(v)=\ell$. Once found, we remove $v$ from $V$
and any edge $(u,v)\in E$ is replaced by $(u,w_1)$
and $(u,w_2)$, where $w_1.w_2\in V$ were the children of $v$
in $T$.

\subsubsection{Sorting}

A binary search tree can be used to implement a simple but efficient
sorting algorithm. Suppose we wish to sort a list of numbers
$L = [\ell_1, \ell_2,\dots, \ell_n]$. First, let $V=\{1,2,\dots,n\}$
be the vertices of a tree and weight vertex $i$ with $\ell_i$,
for $1\leq i\leq n$. In this case, we can traverse this tree
in order of its weights, thereby building a BST recursively.
This BST represents the sorting of the list $L$.
