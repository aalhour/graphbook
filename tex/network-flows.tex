%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% This file is part of the book
%%
%% Algorithmic Graph Theory
%% http://code.google.com/p/graph-theory-algorithms-book/
%%
%% Copyright (C) 2009--2011 Minh Van Nguyen <nguyenminh2@gmail.com>
%%
%% See the file COPYING for copying conditions.
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\chapter{Network Flows}
\label{chap:network_flows}

See Jungnickel~\cite{Jungnickel2008}, and chapter~12 of Gross and
Yellen~\cite{GrossYellen1999}.


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\section{Flows and cuts}

\begin{itemize}
\item single source-single sink networks

\item feasible networks

\item maximum flow and minimum cut
\end{itemize}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\section{Ford-Fulkerson theorem}

The Ford-Fulkerson Theorem, or ``Max-flow/Min-cut Theorem,''
was proven by P. Elias, A. Feinstein, and C.E. Shannon in 1956, and,
independently, by L.R. Ford, Jr.  and D.R. Fulkerson in the same year.
So it should be called the
``Elias-Feinstein-Ford-Fulkerson-Shannon Theorem,''
to be precise about the authorship.

To explain the meaning of this theorem, we need to introduce some
notation and  terminology.

Consider an edge-weighted simple
digraph $G=(V,E,i,h)$ without negative weight
cycles. Here $E\subset V^{(2)}$,
$i$ is an incidence function as in~\eqref{eqn:edge-incidence}, which
we regard as the identity function, and $h$ is an
orientation function as in~\eqref{eqn:edge-orientation}.
Let $G$ be a {\it network},
\index{network}
with two distinguished vertices, the ``source'' and the ``sink.''
Let $s$ and $t$ denote the source and the sink of $G$, respectively.
The {\it capacity} (or {\it edge capacity})
\index{capacity}
\index{edge!capacity})
is a mapping $c: E \to {\mathbf{R}}$, denoted by $c_{uv}$
or $c(u,v)$, for $(u,v)\in E$ and $h(e)= u$.
If $(u,v)\in E$ and $h(e)= v$
then we set, by convention, $c(v,u)=-c(u,v)$.
Thinking of a graph as a network of pipes (representing the edges)
transporting water with various junctions (representing vertices),
the capacity function represents the maximum amount
of ``flow'' that can pass through an edge.

A {\it flow}
\index{flow}
is a mapping $f: E \to {\mathbf{R}}$, denoted by $f_{uv}$ or
$f(u,v)$, subject to the following two constraints:
\begin{itemize}
\item
$f(u,v)\leq c(u,v)$, for each $(u,v) \in V$ (the ``capacity constraint''),
\item
$\sum_{u\in V,\ (u,v)\in E} f(u,v) = \sum_{u\in V,\ (v, u)\in E} f(v, u)$ ,
for each $v\in V$ (conservation of flows).
\end{itemize}
An edge $(u,v) \in E$ is {\it $f$-saturated}
\index{$f$-saturated}
\index{saturated edge}
if $f(u,v)=c(u,v)$.
An edge $(u,v) \in E$ is {\it $f$-zero} if $f(u,v)=0$.
\index{$f$-zero}
A path with available capacity is called an ``augmenting path.''
More precisely, a directed path form $s$ to $t$ is
{\it $f$-augmenting}, or
\index{$f$-augmenting}
\index{$f$-unsaturated}
\index{augmenting path}
$f$-unsaturated, if no forward
edge is $f$-saturated and no backward edge is $f$-zero.

The {\it value of the flow} is defined by

\[
| f | = \sum_{v\in V}f(s,v)-\sum_{v\in V}f(v,s),
\]
where $s$ is the source.
It represents the amount of flow passing from the source to the sink.
\index{flow!value}
\index{value of flow}
The {\it maximum flow problem} is to maximize $| f |$, that is, to route as
much flow as possible from $s$ to $t$.
\index{maximum flow problem}

\begin{example}
{\rm
Consider the digraph having adjacency matrix

\[
\left(\begin{array}{cccccc}
0 & 1 & 1 & 0 & 0 & 0 \\
-1 & 0 & -1 & 1 & 0 & 1 \\
-1 & 1 & 0 & 0 & 1 & 0 \\
0 & -1 & 0 & 0 & 0 & 1 \\
0 & 0 & -1 & 0 & 0 & 1 \\
0 & -1 & 0 & -1 & -1 & 0
\end{array}\right),
\]
depicted in Figure \ref{fig:network_flows:digraph_flow}.

\begin{figure}[!htbp]
\centering
\includegraphics{image/network-flows/digraph-flow}
\caption{A digraph with $6$ vertices.}
\label{fig:network_flows:digraph_flow}
\end{figure}
Suppose that each edge has capacity $1$.
A maximum flow $f$ is obtained by taking a flow value
of $1$ along each edge of the path

\[
p_1:(0,1),(1,5),
\]
and a flow value
of $1$ along each edge of the path

\[
p_2:(0,2),(2,4),(4,5).
\]
The maximum value of the flow in this case is $|f|=2$.

This graph can be created in Sage using the commands

\begin{lstlisting}
sage: B = matrix([[0,1,1,0,0,0],[0,0,0,1,0,1],[0,1,0,0,1,0],[0,0,0,0,0,1],[0,0,0,0,0,1],[0,0,0,0,0,0]])
sage: H = DiGraph(B, format = "adjacency_matrix", weighted=True)
\end{lstlisting}

\noindent
Type {\tt H.show(edge\_labels=True)} if you want to see the graph with
the capacities labeling the edges.


}
\end{example}


Given a capacitated digraph with capacity $c$ and flow $f$,
we define the {\it residual digraph} $G_f=(V,E)$ to be the
digraph with capacity $c_f(u,v) = c(u,v) - f(u,v)$ and no flow.
In other words, $G_f$ is the same graph but it has a different
capacity $c_f$ and flow $0$.
\index{residual digraph}
This is also called a {\it residual network}.
\index{residual network}

Define an {\it $s-t$ cut} in our capacitated digraph $G$
to be a partition $C = (S,T)$ of $V$ such that
$s \in S$ and $t\in T$.
Recall the cut-set of $C$ is the set

\[
\{(u,v)\in E\ |\ u\in S, v\in T\}.
\]

\begin{lemma}
\label{lemma:flow=0}
{\rm
Let $G = (V, E)$ be a capacitated digraph with
capacity $c: E \to {\mathbf{R}}$, and let
$s$ and $t$ denote the source and the sink of $G$, respectively.
If $C$ is an $s-t$ cut and if
the edges in the cut-set of $C$ are removed, then $| f | = 0$.
}
\end{lemma}

\begin{exercise}
Prove Lemma \ref{lemma:flow=0}.
\end{exercise}

The {\it capacity of an $s-t$ cut}
\index{capacity!cut}
$C = (S,T)$ is defined by

\[
c(S,T) = \sum_{(s,t)\in (S,T)} c(u,v).
\]
The {\it minimum cut problem}
\index{minimum cut problem}
is to minimize the amount of capacity of an $s-t$ cut.

The following theorem is due to P. Elias, A. Feinstein, L.R. Ford,
Jr.,  D.R. Fulkerson, C.E. Shannon.

\begin{theorem}
(max-flow min-cut theorem)
{\rm
The maximum value of an $s$-$t$ flow is equal to the minimum capacity of
an $s$-$t$ cut.
}
\end{theorem}
\index{max-flow min-cut theorem}

The intuitive explanation of this result is as follows.

Suppose that $G=(V,E)$ is a graph where each edge has capacity $1$.
Let $s\in V$ be the source and $t\in V$ be the sink.
The maximum flow from $s$ to $t$ is the maximum number of
independent paths from $s$ to $t$.
Denote this maximum flow by $m$.
Each $s$-$t$ cut must intersect each $s$-$t$ path at least once.
In fact, if $S$ is a minimal $s$-$t$ cut then for each
edge $e$ in $S$ there is an $s$-$t$ path containing
$e$. Therefore, $|S|\leq e$.

On the other hand, since each edge has unit capacity,
the maximum flow value can't exceed the number of
edges separating $s$ from $t$, so $m\leq |S|$.


\begin{remark}
Although the notion of an independent path is important
for the network-theoretic proof of Menger's theorem
(which we view as a corollary to the Ford-Fulkerson
theorem on network flows on networks having
capacity $1$ on all edges), its significance is less
important for networks having arbitrary capacities.
One must use caution in generalizing the above
intuitive argument to establish a rigorous proof
of the general version of the MFMC theorem.
\end{remark}

\begin{remark}
\label{remark:GMCMF}
{\rm
This theorem can be generalized as follows.
In addition to edge capacity, suppose there is capacity at each {\it vertex},
that is, a mapping $c: V \to {\mathbf{R}}$, denoted by
$v \mapsto c(v)$, such that the flow $f$ has to
satisfy not only the capacity constraint and the conservation of flows,
but also the vertex capacity constraint

\[
 \sum_{w\in V} f(w,v) \leq c(v),
\]
for each $v \in V-\{s,t\}$.
Define an {\it $s-t$ cut} to be the set of vertices and edges such
that for any path from $s$ to $t$, the path contains a member of the cut.
In this case, the capacity of the cut is the sum the capacity of each
edge {\it and} vertex in it.
In this new definition, the {\it generalized max-flow min-cut theorem}
\index{max-flow min-cut theorem!generalized}
states that the maximum value of an $s-t$ flow is equal to the minimum
capacity of an $s-t$ cut..
}
\end{remark}

The idea behind the Ford-Fulkerson algorithm is very simple: As long as
there is a path from the source to the sink, with
available capacity on all edges in the
path, we send as much flow as we can alone along each
of these paths. This is done inductively, one path at a time.

\begin{algorithm}[!htbp]
\input{algorithm/distance-connectivity/ford-fulkerson.tex}
\caption{Ford-Fulkerson algorithm.}
\label{alg:distance-connectivity:ford-fulkerson}
\end{algorithm}

To prove the max-flow/min-cut theorem we will use the following lemma.

\begin{lemma}
{\rm
Let $G=(V,E)$ be a directed graph with edge
capacity $c: E \to {\mathbf{Z}}$,
a source $s\in V$, and a sink $t\in V$.
A flow $f: E \to {\mathbf{Z}}$ is a maximum flow if
and only if there is no $f$-augmenting path in the graph.
}
\end{lemma}

In other words, a flow $f$ in a
capacitated network is a maximum flow if and only if
there is no $f$-augmenting path in the network.

\begin{proof}[Solution]
One direction is easy. Suppose that the flow is a maximum.
If there is an $f$-augmenting path then the
current flow can be increased using that path, so the flow would not
be a maximum. This contradiction proves the ``only if'' direction.

Now, suppose there is no $f$-augmenting path in the network.
Let $S$ be the set of vertices $v$ such that there is an $f$-unsaturated path from
the source $s$ to $v$. We know $s\in S$ and (by hypothesis)
$t\notin S$. Thus there is a cut of the form $(S,T)$ in the network.
Let $e=(v,w)$ be any edge in this cut, $v\in S$ and $w\in T$. Since
there is no $f$-unsaturated path from $s$ to $w$,
$e$ is $f$-saturated. Likewise, any edge in the cut
$(T,S)$ is $f$-zero. Therefore, the current flow value is equal to the
capacity of the cut $(S,T)$. Therefore, the current flow is a maximum.
\end{proof}

We can now prove the max-flow/min-cut theorem.

\begin{proof}[Solution]
Let $f$ be a maximum flow.
If

\[
S = \{v\in V\ |\ {\rm there\ exists\ an\ }f-{\rm saturated\ path\
  from\ }s\ {\rm to\ }v\},
\]
then by the previous lemma, $S\not= V$.
Since $T=V-S$ is non-empty, there is a cut $C=(S,T)$.
Each edge of this cut $C$ in the capacitated network $G$ is
$f$-saturated.

\end{proof}

Here is some Python code\footnote{Please see
\url{http://en.wikipedia.org/wiki/Ford-Fulkerson_algorithm}.}
which implements this. The class {\tt FlowNetwork} is basically a Sage
Graph class with edge weights and an extra data structure representing
the flow on the graph.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% TODO: Translate this into Sage
%% easiler said than done, since the flow "record" is missing from
%% Sage. One way: create new functions "find_path" and "max_flow"
%% similar to the ones below but with a new argument
%% "flow" which is a function on the edges of G. Maybe there
%% is a better way??
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{lstlisting}
class Edge:
    def __init__(self,U,V,w):
        self.source = U
        self.to = V
        self.capacity = w
    def __repr__(self):
        return str(self.source) + "->" + str(self.to) + " : " + str(self.capacity)

class FlowNetwork(object):
    """
    This is a graph structure with edge capacities.

    EXAMPLES:
        g=FlowNetwork()
        map(g.add_vertex, ['s','o','p','q','r','t'])
        g.add_edge('s','o',3)
        g.add_edge('s','p',3)
        g.add_edge('o','p',2)
        g.add_edge('o','q',3)
        g.add_edge('p','r',2)
        g.add_edge('r','t',3)
        g.add_edge('q','r',4)
        g.add_edge('q','t',2)
        print g.max_flow('s','t')
    """
    def __init__(self):
        self.adj, self.flow, = {},{}

    def add_vertex(self, vertex):
        self.adj[vertex] = []

    def get_edges(self, v):
        return self.adj[v]

    def add_edge(self, u,v,w=0):
        assert(u != v)
        edge = Edge(u,v,w)
        redge = Edge(v,u,0)
        edge.redge = redge
        redge.redge = edge
        self.adj[u].append(edge)
        self.adj[v].append(redge)
        self.flow[edge] = self.flow[redge] = 0

    def find_path(self, source, sink, path):
        if source == sink:
            return path
        for edge in self.get_edges(source):
            residual = edge.capacity - self.flow[edge]
            if residual > 0 and not (edge,residual) in path:
                result = self.find_path(edge.to, sink, path + [ (edge,residual) ])
                if result != None:
                    return result

    def max_flow(self, source, sink):
        path = self.find_path(source, sink, [])
        while path != None:
            flow = min(res for edge,res in path)
            for edge,res in path:
                self.flow[edge] += flow
                self.flow[edge.redge] -= flow
            path = self.find_path(source, sink, [])
        return sum(self.flow[edge] for edge in self.get_edges(source))
\end{lstlisting}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\section{Edmonds and Karp's algorithm}

The objective of this section is to prove Edmond and Karp's algorithm
for the maximum flow-minimum cut problem with polynomial
complexity.


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\section{Goldberg and Tarjan's algorithm}

The objective of this section is to prove Goldberg and Tarjan's
algorithm for finding maximal flows with polynomial complexity.
